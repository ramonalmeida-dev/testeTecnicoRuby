<!-- Modal de Filtros -->
<div id="filterModal" class="filter-modal" style="display: none;">
  <div class="filter-modal-backdrop" onclick="closeFilterModal()"></div>
  
  <div class="filter-modal-content">
    <!-- Header -->
    <div class="filter-modal-header">
      <h3 class="filter-modal-title">Filtrar indicador</h3>
      <button type="button" class="filter-modal-close" onclick="closeFilterModal()">
        <span>&times;</span>
      </button>
    </div>

    <!-- Body -->
    <div class="filter-modal-body">
      <form id="filterForm" data-filter-modal-target="form">
        
        <!-- Grupos de Filtros -->
        <div class="filter-groups" data-filter-modal-target="groupsContainer">
          <!-- Grupos adicionados dinamicamente -->
        </div>



      </form>
    </div>

    <!-- Footer -->
    <div class="filter-modal-footer">
      <!-- Botão Adicionar Filtro (à esquerda) -->
      <button type="button" 
              class="btn btn-outline-secondary add-filter-group" 
              onclick="addGroup()">
        <span class="plus-icon">+</span> Adicionar filtro
      </button>
      
      <!-- Botões de ação (à direita) -->
      <div class="filter-modal-actions">
        <button type="button" 
                class="btn btn-secondary" 
                onclick="clearFilters()">
          Limpar filtros
        </button>
        <button type="button" 
                class="btn btn-primary" 
                onclick="applyFilters()">
          Aplicar filtro
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Template para Grupo de Filtros -->
<template id="filterGroupTemplate">
  <div class="filter-group">
    
    <!-- Operador do Grupo (Onde/OU) -->
    <div class="group-operator-section">
      <select class="group-operator-select">
        <option value="WHERE">Onde</option>
        <option value="OR">Ou</option>
      </select>
    </div>

    <!-- Container dos Filtros -->
    <div class="group-filters-container">
      <!-- Lista de Filtros -->
      <div class="group-filters">
        <!-- Filtros individuais aqui -->

        <!-- Botão dentro do container -->
        <div class="filter-add-inside">
          <button type="button" 
                  class="btn btn-link add-grouped-filter" 
                  onclick="addFilterToGroup(this)">
            <span class="plus-icon">+</span> Adicionar filtro agrupado
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<!-- Template para Filtro Individual -->
<template id="filterTemplate">
  <div class="filter-row">
    
    <!-- Operador entre filtros (só aparece do 2º em diante) -->
    <div class="filter-operator-section" style="display: none;">
      <select class="filter-operator-select">
        <option value="AND">E</option>
        <option value="OR">Ou</option>
      </select>
    </div>

    <!-- Filtro -->
    <div class="filter-main">
      
      <!-- Campo -->
      <div class="filter-field-section">
        <label class="filter-label">Onde</label>
        <select class="filter-field-select">
          <option value="">Selecione o campo</option>
          <% filter_field_options.each do |label, value| %>
            <option value="<%= value %>" data-type="<%= filter_field_type(value) %>"><%= label %></option>
          <% end %>
        </select>
      </div>

      <!-- Valor -->
      <div class="filter-value-section">
        <input type="text" class="filter-value-input" placeholder="Valor">
      </div>

      <!-- Remover -->
      <div class="filter-remove-section">
        <button type="button" class="btn btn-remove-filter" onclick="removeFilter(this)">
          Limpar
        </button>
      </div>
    </div>
  </div>
</template>

<script>
// ===== CONFIGURAÇÃO =====
// Cache buster: <%= Time.current.to_i %>
const FilterConfig = {
  fieldOptions: <%= filter_field_options.to_json.html_safe %>,
  fieldTypes: {
    <% filter_field_options.each do |label, field| %>
      "<%= field %>": "<%= filter_field_type(field) %>"<%= ',' unless field == filter_field_options.last[1] %>
    <% end %>
  },
  valueOptions: {
    <% filter_field_options.each do |label, field| %>
      "<%= field %>": <%= filter_value_options(field).to_json.html_safe %><%= ',' unless field == filter_field_options.last[1] %>
    <% end %>
  },
  maxGroups: <%= max_groups %>,
  maxFiltersPerGroup: <%= max_filters_per_group %>
};

// ===== FUNÇÕES DO MODAL =====
function openFilterModal() {
  const modal = document.getElementById('filterModal');
  if (modal) {
    modal.style.display = 'flex';
    document.body.style.overflow = 'hidden';
    
    // Se não há grupos, adicionar o primeiro
    const groupsContainer = document.querySelector('[data-filter-modal-target="groupsContainer"]');
    if (groupsContainer && groupsContainer.children.length === 0) {
      addInitialGroup();
    }
  }
}

function closeFilterModal() {
  const modal = document.getElementById('filterModal');
  if (modal) {
    modal.style.display = 'none';
    document.body.style.overflow = '';
  }
}

function clearFilters() {
  const groupsContainer = document.querySelector('[data-filter-modal-target="groupsContainer"]');
  if (groupsContainer) {
    groupsContainer.innerHTML = '';
    addInitialGroup();
  }
}

function clearAllFilters() {
  // Fechar o modal
  closeFilterModal();
  
  // Fazer requisição sem filtros e atualizar a página
  fetch('/activities')
    .then(response => response.text())
    .then(html => {
      // Criar um elemento temporário para parsear o HTML
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;
      
      // Extrair a nova tabela
      const newTable = tempDiv.querySelector('table');
      const newDebugInfo = tempDiv.querySelector('p[style*="color: #666"]');
      
      if (newTable) {
        // Substituir a tabela atual
        const currentTable = document.querySelector('table');
        if (currentTable) {
          currentTable.parentNode.replaceChild(newTable, currentTable);
        }
      }
      
      if (newDebugInfo) {
        // Atualizar as informações de debug
        const currentDebugInfo = document.querySelector('p[style*="color: #666"]');
        if (currentDebugInfo) {
          currentDebugInfo.innerHTML = newDebugInfo.innerHTML;
        }
      }
      
      // Atualizar a URL sem recarregar
      const url = new URL(window.location);
      url.searchParams.delete('filters');
      window.history.pushState({}, '', url.toString());
      
      // Atualizar os botões da página para remover o botão "Limpar filtros"
      updatePageButtons(false);
    })
    .catch(error => {
      console.error('Erro ao limpar filtros:', error);
      // Em caso de erro, usar o método tradicional
      const url = new URL(window.location);
      url.searchParams.delete('filters');
      window.location.href = url.toString();
    });
}

function applyFilters() {
  const filterData = collectFilterData();
  
  if (validateFilters(filterData)) {
    // Mostrar loading
    showLoading();
    
    // Fechar o modal
    closeFilterModal();
    
    // Aplicar filtros via AJAX (atualização dinâmica)
    fetch('/activities?filters=' + encodeURIComponent(JSON.stringify(filterData)))
      .then(response => response.text())
      .then(html => {
        // Criar um elemento temporário para parsear o HTML
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;
        
        // Extrair o novo container da tabela
        const newTableContainer = tempDiv.querySelector('#tableContainer');
        
        if (newTableContainer) {
          // Substituir o container atual
          const currentContainer = document.getElementById('tableContainer');
          if (currentContainer) {
            currentContainer.innerHTML = newTableContainer.innerHTML;
          }
        }
        
        // Atualizar a URL sem recarregar
        const url = new URL(window.location);
        url.searchParams.set('filters', encodeURIComponent(JSON.stringify(filterData)));
        window.history.pushState({}, '', url.toString());
        
        // Atualizar os botões da página para mostrar o botão "Limpar filtros"
        updatePageButtons(true);
        
        // Esconder loading
        hideLoading();
      })
      .catch(error => {
        console.error('Erro ao aplicar filtros:', error);
        hideLoading();
        // Em caso de erro, usar o método tradicional (recarregar página)
        const url = new URL(window.location);
        url.searchParams.set('filters', encodeURIComponent(JSON.stringify(filterData)));
        window.location.href = url.toString();
      });
  }
}

// ===== FUNÇÕES DE GRUPOS =====
function addInitialGroup() {
  const groupsContainer = document.querySelector('[data-filter-modal-target="groupsContainer"]');
  const template = document.getElementById('filterGroupTemplate');
  
  if (template && groupsContainer) {
    const groupElement = template.content.cloneNode(true);
    
    // Primeiro grupo sempre usa "Onde"
    const groupOperatorSelect = groupElement.querySelector('.group-operator-select');
    if (groupOperatorSelect) {
      groupOperatorSelect.value = 'WHERE';
      groupOperatorSelect.disabled = true;
    }
    
    groupsContainer.appendChild(groupElement);
    
    // Adicionar filtro inicial
    setTimeout(() => {
      const filtersContainer = groupsContainer.querySelector('.group-filters');
      addFilterToContainer(filtersContainer, true);
    }, 50);
  }
}

function addGroup() {
  const groupsContainer = document.querySelector('[data-filter-modal-target="groupsContainer"]');
  const template = document.getElementById('filterGroupTemplate');
  
  if (!template || !groupsContainer) return;
  
  // Verificar limite
          if (groupsContainer.children.length >= FilterConfig.maxGroups) {
          alert(`Máximo de ${FilterConfig.maxGroups} grupos permitidos`);
    return;
  }
  
  const groupElement = template.content.cloneNode(true);
  
  // Novos grupos usam "OU"
  const groupOperatorSelect = groupElement.querySelector('.group-operator-select');
  if (groupOperatorSelect) {
    groupOperatorSelect.value = 'OR';
  }
  
  groupsContainer.appendChild(groupElement);
  
  // Adicionar filtro inicial
  setTimeout(() => {
    const newGroup = groupsContainer.lastElementChild;
    const filtersContainer = newGroup.querySelector('.group-filters');
    addFilterToContainer(filtersContainer, true);
  }, 50);
}

// ===== FUNÇÕES DE FILTROS =====
function addFilterToGroup(button) {
  
  const groupElement = button.closest('.filter-group');
  const filtersContainer = groupElement.querySelector('.group-filters');
  const template = document.getElementById('filterTemplate');
  
  if (!template || !filtersContainer) return;
  
  // Verificar limite de filtros por grupo
  const currentFilters = filtersContainer.querySelectorAll('.filter-row').length;
          if (currentFilters >= FilterConfig.maxFiltersPerGroup) {
          alert(`Máximo de ${FilterConfig.maxFiltersPerGroup} filtros por grupo`);
    return;
  }
  
  const filterElement = template.content.cloneNode(true);
  
  // Se já existe algum filtro, exibe o operador
  if (currentFilters > 0) {
    const operatorSection = filterElement.querySelector('.filter-operator-section');
    if (operatorSection) {
      operatorSection.style.display = 'flex';
    }
  }
  
  // Insere o novo filtro antes do botão "Adicionar filtro agrupado"
  const addButton = filtersContainer.querySelector('.filter-add-inside');
  filtersContainer.insertBefore(filterElement, addButton);
  
  // Configurar eventos do novo filtro
  const newFilterRow = addButton.previousElementSibling;
  setupFilterEvents(newFilterRow);
}

function addFilterToContainer(filtersContainer, isFirst = false) {
  const template = document.getElementById('filterTemplate');
  
  if (template && filtersContainer) {
    const filterElement = template.content.cloneNode(true);
    
    // Mostrar operador apenas se não for o primeiro
    const currentFilters = filtersContainer.querySelectorAll('.filter-row').length;
    
    const operatorSection = filterElement.querySelector('.filter-operator-section');
    if (operatorSection) {
      operatorSection.style.display = (currentFilters > 0 && !isFirst) ? 'flex' : 'none';
    }
    
    // Insere antes do botão "Adicionar filtro agrupado"
    const addButton = filtersContainer.querySelector('.filter-add-inside');
    if (addButton) {
      filtersContainer.insertBefore(filterElement, addButton);
    } else {
      filtersContainer.appendChild(filterElement);
    }
    
    // Configurar eventos do novo filtro
    const newFilterRow = addButton ? addButton.previousElementSibling : filtersContainer.lastElementChild;
    setupFilterEvents(newFilterRow);
  }
}

function removeFilter(button) {

  const filterRow = button.closest('.filter-row');
  const filtersContainer = filterRow.parentElement;
  
  filterRow.remove();
  
  // Reconfigurar operadores dos filtros restantes
  const remainingFilters = filtersContainer.querySelectorAll('.filter-row');
  remainingFilters.forEach((filter, index) => {
    const operatorSection = filter.querySelector('.filter-operator-section');
    if (operatorSection) {
      operatorSection.style.display = index === 0 ? 'none' : 'flex';
    }
  });
  
  // Se não há mais filtros, adicionar um novo
  if (remainingFilters.length === 0) {
    addFilterToContainer(filtersContainer, true);
  }
}

// ===== EVENTOS DOS CAMPOS =====
function setupFilterEvents(filterRow) {
  const fieldSelect = filterRow.querySelector('.filter-field-select');
  
  if (fieldSelect) {
    fieldSelect.addEventListener('change', function() {
      // Sempre buscar o valueInput atual, pois pode ter sido substituído
      const currentValueInput = filterRow.querySelector('.filter-value-input');
      updateValueInput(this, currentValueInput);
    });
  }
}

function updateValueInput(fieldSelect, valueInput) {
  const field = fieldSelect.value;
          const fieldType = FilterConfig.fieldTypes[field];
        const valueOptions = FilterConfig.valueOptions[field];
  
  if (!field || !valueInput) return;
  
  // Se tem opções, criar select
  if (valueOptions && valueOptions.length > 0) {
    // Se já é um select, apenas atualizar as opções
    if (valueInput.tagName === 'SELECT') {
      valueInput.innerHTML = '<option value="">Selecione...</option>';
      valueOptions.forEach(([label, value]) => {
        const option = document.createElement('option');
        option.value = value;
        option.textContent = label;
        valueInput.appendChild(option);
      });
    } else {
      // Se é um input, substituir por select
      const select = document.createElement('select');
      select.className = 'filter-value-input';
      select.innerHTML = '<option value="">Selecione...</option>';
      
      valueOptions.forEach(([label, value]) => {
        const option = document.createElement('option');
        option.value = value;
        option.textContent = label;
        select.appendChild(option);
      });
      
      valueInput.parentNode.replaceChild(select, valueInput);
    }
  } else {
    // Se não tem opções, garantir que é um input
    if (valueInput.tagName === 'SELECT') {
      // Se é um select, substituir por input
      const input = document.createElement('input');
      input.className = 'filter-value-input';
      input.placeholder = 'Valor';
      input.value = ''; // Limpar valor anterior
      
      // Configurar input por tipo
      switch (fieldType) {
        case 'date':
        case 'datetime':
          input.type = 'date';
          input.className = 'filter-value-input date-select';
          break;
        case 'integer':
        case 'float':
          input.type = 'number';
          break;
        default:
          input.type = 'text';
          input.className = field === 'user_id' ? 'filter-value-input user-select' : 'filter-value-input';
      }
      
      valueInput.parentNode.replaceChild(input, valueInput);
    } else {
      // Se já é um input, apenas atualizar o tipo e limpar
      valueInput.value = ''; // Limpar valor anterior
      switch (fieldType) {
        case 'date':
        case 'datetime':
          valueInput.type = 'date';
          valueInput.className = 'filter-value-input date-select';
          break;
        case 'integer':
        case 'float':
          valueInput.type = 'number';
          break;
        default:
          valueInput.type = 'text';
          valueInput.className = field === 'user_id' ? 'filter-value-input user-select' : 'filter-value-input';
      }
    }
  }
}

// ===== FUNÇÕES AUXILIARES =====
function getDefaultOperatorForField(field) {
  const fieldType = FilterConfig.fieldTypes[field];
  
  switch (fieldType) {
    case 'string':
      return 'icontains'; // Case-insensitive para campos de texto
    case 'integer':
    case 'float':
    case 'boolean':
    case 'date':
    case 'datetime':
      return 'equals';
    default:
      return 'equals';
  }
}

// ===== COLETA DE DADOS =====
function collectFilterData() {
  const groups = [];
  const groupsContainer = document.querySelector('[data-filter-modal-target="groupsContainer"]');
  
  if (!groupsContainer) return { groups: [] };
  
  groupsContainer.querySelectorAll('.filter-group').forEach(groupElement => {
    const groupOperatorSelect = groupElement.querySelector('.group-operator-select');
    const groupOperator = groupOperatorSelect ? groupOperatorSelect.value : 'AND';
    
    const filters = [];
    const filterRows = groupElement.querySelectorAll('.filter-row');
    
    filterRows.forEach((filterRow, filterIndex) => {
      const fieldSelect = filterRow.querySelector('.filter-field-select');
      const valueInput = filterRow.querySelector('.filter-value-input');
      const operatorSelect = filterRow.querySelector('.filter-operator-select');
      
      if (fieldSelect && valueInput && fieldSelect.value && valueInput.value) {
        // Selecionar operador padrão baseado no tipo do campo
        const defaultOperator = getDefaultOperatorForField(fieldSelect.value);
        
        filters.push({
          field: fieldSelect.value,
          operator: defaultOperator,
          value: valueInput.value,
          operator_with_previous: filterIndex > 0 ? (operatorSelect?.value || 'AND') : 'AND'
        });
      }
    });
    
    if (filters.length > 0) {
      groups.push({
        operator: groupOperator,
        filters: filters
      });
    }
  });
  
  return {
    groups: groups,
    group_operator: groups.length > 1 ? 'OR' : 'AND'
  };
}

function validateFilters(filterData) {
  if (!filterData.groups || filterData.groups.length === 0) {
    alert('Adicione pelo menos um filtro');
    return false;
  }
  
  for (let group of filterData.groups) {
    for (let filter of group.filters) {
      if (!filter.field || !filter.value) {
        alert('Todos os campos devem ser preenchidos');
        return false;
      }
    }
  }
  
  return true;
}



// ===== ATUALIZAÇÃO DOS BOTÕES DA PÁGINA =====
function updatePageButtons(hasFilters) {
  const clearButton = document.getElementById('clearFiltersBtn');
  if (clearButton) {
    clearButton.disabled = !hasFilters;
  }
}

// ===== INICIALIZAÇÃO =====
document.addEventListener('DOMContentLoaded', function() {
  // Mensagem para análise técnica
console.log('%cTeste técnico: Sistema de filtros avançado implementado!', 'color: #0284C7; font-size: 14px; font-weight: bold;');
console.log('%cFuncionalidades: Filtros múltiplos, grupos OR/AND, AJAX, case-insensitive', 'color: #059669; font-size: 12px;');
console.log('%cCobertura: 74 testes passando, arquitetura escalável, boas práticas', 'color: #7C3AED; font-size: 12px;');
});
</script>
